java_file(imports, javaDef) ::= <<
<if(javaDef.packageName)>package <javaDef.packageName>;<endif>

<imports:{ im | import <im>;}; separator="\n">

<javaDef.annotations:annotation_instance();separator="\n">
<if(javaDef.classType)><javaDef:class_file()><elseif(javaDef.enumType)><javaDef:enum_file()><elseif(javaDef.interfaceType)><javaDef:interface_file()><endif>
>>

class_file(classDef) ::= <<
<if(classDef.accessModifier)><classDef.accessModifier> <endif><if(classDef.abstract)>abstract <endif>class <classDef.name><classDef.typeParameters:type_parameter()><if(classDef.superClass)> extends <classDef.superClass.name><endif><if(classDef.interfaces)> implements <classDef.interfaces:{iface | <iface.name>};separator=", "><endif>{
    <classDef.attributes:attribute()>
    <classDef.constructors:method()>
    <classDef.concreteMethods:method()>
}
>>

enum_file(enumDef) ::= <<
<if(enumDef.accessModifier)><enumDef.accessModifier> <endif>enum <enumDef.name><if(enumDef.interfaces)> implements <enumDef.interfaces:{iface | <iface.name>};separator=", "><endif>{
    <enumDef.values:{v | <v>};separator=",\n">;
    <enumDef.attributes:attribute()>
    <enumDef.constructors:method()>
    <enumDef.concreteMethods:method()>
}
>>

interface_file(interfaceDef) ::= <<
<if(interfaceDef.accessModifier)><interfaceDef.accessModifier> <endif>interface <interfaceDef.name><interfaceDef.typeParameters:type_parameter()><if(interfaceDef.superInterface)> extends <interfaceDef.superInterface.name><endif><if(interfaceDef.interfaces)> implements <classDef.interfaces:{iface | <iface.name>};separator=", "><endif>{
    <interfaceDef.abstractMethods:method()>
>>



type_parameter(typeParameter) ::= <<
\<<typeParameter.names:{tpn | <tpn.name>};separator=","><if(typeParameter.parentTypes)> extends <typeParameter.parentTypes:{td | <td.name>};separator=" & "><endif>\>
>>

attribute(attrDef) ::= <<

<attrDef.annotations:annotation_instance();separator="\n">
<if(attrDef.accessModifier)><attrDef.accessModifier> <endif><attrDef:id_declaration()>;
>>

method(methodDef) ::= <<


<methodDef.annotations:annotation_instance();separator="\n">
<if(methodDef.constructor)><methodDef:constructor_method()><elseif(methodDef.concrete)><methodDef:concrete_method()><elseif(methodDef.abstract)><methodDef:abstract_method()><endif>
>>

constructor_method(methodDef) ::= <<
<if(methodDef.accessModifier)><methodDef.accessModifier> <endif><methodDef.typeParameters:type_parameter()><methodDef.returnType:type_definition()>(<methodDef.parameters:method_parameters();separator=", ">){
    <if(methodDef.body)><methodDef.body>;<endif>
}
>>

concrete_method(methodDef) ::= <<
<if(methodDef.accessModifier)><methodDef.accessModifier> <endif><if(methodDef.static)>static <endif><methodDef.typeParameters:type_parameter()><if(methodDef.returnType)><methodDef.returnType:type_definition()><else>void<endif> <methodDef.name>(<methodDef.parameters:method_parameters();separator=", ">){
    <if(methodDef.body)><methodDef.body>;<endif>
    <if(methodDef.returnType)>return <if(methodDef.returnValue)><methodDef.returnValue><else>null<endif>;<endif>
}
>>

abstract_method(methodDef) ::= <<
<if(methodDef.accessModifier)><methodDef.accessModifier> <endif><if(methodDef.static)>static <endif>abstract <methodDef.typeParameters:type_parameter()><if(methodDef.returnType)><methodDef.returnType:type_definition()><else>void<endif> <methodDef.name>(<methodDef.parameters:method_parameters();separator=", ">);
>>

method_parameters(parameter) ::= <<
<if(parameter.annotations)><parameter.annotations:annotation_instance();separator=" "> <endif><parameter:id_declaration()>
>>

id_declaration(idDeclaration) ::= <<
<idDeclaration.type:type_definition()> <idDeclaration.name>
>>

type_definition(typeDef) ::= <<
<typeDef.name><if(typeDef.parameterTypes)>\<<typeDef.parameterTypes:type_definition();separator=", ">\><endif>
>>

annotation_instance(annotationInstance) ::= <<
@<annotationInstance.annotation.name><if(annotationInstance.values)>(<annotationInstance.annotation.attributes:{attr| <attr.name>=<annotationInstance.values.(attr.name)>};separator=", ">)<endif>
>>

array_value(type, arraySize) ::= <<
new <type>[<arraySize>]
>>

array_with_values(type, values) ::= <<
new <type>[]{<values:{v | <v>};separator=", ">}
>>

constructor_value(type, args) ::= <<
new <type>(<args:{v | <v>};separator=", ">)
>>

enum_constructor_value(type, args) ::= <<
<type>(<args:{v | <v>};separator=", ">)
>>